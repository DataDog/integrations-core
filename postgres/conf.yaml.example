init_config:

instances:
  - host: localhost
    port: 5432
#    username: my_username
#    password: my_password
#    dbname: db_name
#    ssl: False
#    use_psycopg2: False # Force using psycogp2 instead of pg8000 to connect. WARNING: psycopg2 doesn't support ssl mode.
#    tags:
#      - optional_tag1
#      - optional_tag2

# Connect using a UNIX socket (host must begin with a /)
# If `use_psycopg2` is enabled, use the directory containing the UNIX socket (ex: `/run/postgresql/`)
# otherwise, use the full path to the socket file (ex: `/run/postgresql/.s.PGSQL.5433`).
#  - host: /run/postgresql/.s.PGSQL.5433
#    dbname: db_name

# Track per-relation (table) metrics
# The list of relations/tables must be specified here.
# Each relation generates many metrics (10 + 10 per index)
#
#    relations:
#      - my_table
#      - my_other_table
#
# By default all schemas are included. To track relations from specific schemas only,
# use the following syntax:
#
#    relations:
#      - relation_name: another_table
#        schemas:
#          - public
#          - prod
#


# Custom metrics
# Custom metrics allow you to build custom queries to extract more information from PostgreSQL.
# The format for describing custom metric is identical with the one used for common metrics in postgres.py
# Be extra careful with ensuring proper custom metrics description format. If your custom metric does not work
# after an agent restart, look for errors in the output of "/etc/init.d/datadog-agent info" command, as well as
# /var/log/datadog/collector.log file.
#
# Format:
#   descriptors: is used to add tags to you metrics. It's a list of lists each containing 2 strings. The second
#                one will be the tag name. The first is only here for documentation purposes (usually used to
#                make clear what we are getting from the query). Note that instance tags will be added
#                to that list.
#   metrics: A dict, the key is the query, the value a list containing the name of the metric and its type
#            (RATE, GAUGE or MONOTONIC).
#   query: the base PostgreSQL query. Queries from 'metrics' dict will be inserted here, so you will need
#          to specify where to insert them using '%s' formating operator.
#   relation: if set to 'true', the 'relations' list (see section above) will be available as a second
#             parameter in the query (ie: second '%s'). You can look at 'IDX_METRICS' in the postgres check
#             for an example.
#
# A very simple example
#
#    custom_metrics:
#    - descriptors:
#        - [tag1, node]
#        - [tag2, hostname]
#      metrics:
#         0.5 as idl_time: [postgresql.idl_time, GAUGE]
#         10 as nb_client: [postgresql.nb_client, GAUGE]
#      query: SELECT 'node21', 'someHost', %s;
#      relation: false
#
# The above custom metric will produce the following query in PostgreSQL:
# "SELECT 'node21', 'someHost', 0.5 as idl_time, 10 as nb_client;"
#
# The first two columns in the results will be used for tags ('node:node21', 'hostname:someHost') and the other columns as metrics values.
# At the end the following metrics will be produced:
# {"postgresql.idl_time": 0.5, "type": "GAUGE", "tags": ['node:node21', 'hostname:someHost']}
# {"postgresql.nb_client": 10, "type": "GAUGE", "tags": ['node:node21', 'hostname:someHost']}
#
# Finally, it's important to note that the check will produce as many metrics
# as the number of columns and rows returned by the query. It's up to the user
# to make sure each association of the metric name and tags is unique. If not
# the metrics will overwrite each other.
#
# Below a more complex example.
#
#    custom_metrics:
#    - # Londiste 3 replication lag
#      descriptors:
#        - [consumer_name, consumer_name]
#      metrics:
#         GREATEST(0, EXTRACT(EPOCH FROM lag)) as lag: [postgresql.londiste_lag, GAUGE]
#         GREATEST(0, EXTRACT(EPOCH FROM lag)) as last_seen: [postgresql.londiste_last_seen, GAUGE]
#         pending_events: [postgresql.londiste_pending_events, GAUGE]
#      query: SELECT consumer_name, %s from pgq.get_consumer_info() where consumer_name !~ 'watermark$';
#      relation: false

#    Collect metrics regarding PL/pgSQL functions from pg_stat_user_functions
#    collect_function_metrics: False
#

#    Collect count metrics, default value is True for backward compatibility but they might be slow,
#    suggested value is False.
#    collect_count_metrics: False
#

#    Collect database size metrics. Default value is True but they might be slow with large databases
#    collect_database_size_metrics: False
#
