# Generate metrics_generated.py from metadata.csv.
#
# WHAT: Extracts metric names and types from metadata.csv and generates Python code
#       containing METRIC_DATA list used by the Prometheus check.
#
# WHY:  Couchbase's Prometheus endpoint often omits or incorrectly specifies metric
#       TYPE metadata. This causes OpenMetrics to assign "unknown" type to metrics,
#       which results in metrics being silently discarded. By generating metric type
#       information from our curated metadata.csv, we can provide type_overrides to
#       OpenMetricsBaseCheck, ensuring all metrics are collected with correct types.
#
#       This also provides metric name mappings to transform Couchbase's raw metric
#       names (e.g., "kv_dcp_backoff") into Datadog-style names (e.g., "kv.dcp_backoff").
#
# Usage: scripts/generate_metrics_code.py < metadata.csv > datadog_checks/couchbase/metrics_generated.py
#

import csv
import datetime
import pprint


def get_metric_data_from_metadata_csv(f):
    """Parse metadata.csv from the supplied file."""
    metric_data = []

    reader = csv.DictReader(f)
    for row in reader:
        _, metric_name_without_namespace = row["metric_name"].split(".", 1)
        metric_data.append(
            {
                "metric_name": metric_name_without_namespace,
                "metric_type": row["metric_type"],
            }
        )

    return metric_data


def generate_metric_data_code(metric_data):
    """Generate Python code for the metric data."""

    timestamp = datetime.datetime.now(datetime.timezone.utc).replace(microsecond=0).isoformat()

    sys.stdout.write("""# This file was auto-generated by couchbase/scripts/generate_metrics_code.py\n""")
    sys.stdout.write(f"""#\n# Generated at: {timestamp}\n""")
    sys.stdout.write("""#
# Many of the metrics from Couchbase's Prometheus/OpenMetrics endpoints either
# don't specify metric types at all, or the metric type is not known to Datadog,
# so this lets us use our curated units from metadata.csv instead.

METRIC_DATA = """)

    metric_data_pretty = pprint.pformat(
        sorted(metric_data, key=lambda md: md["metric_name"]),
        indent=4,
        width=200,
        sort_dicts=True,
    )

    sys.stdout.write(metric_data_pretty)
    sys.stdout.write("  # fmt: skip\n")


if __name__ == "__main__":
    import sys

    metric_metadata = get_metric_data_from_metadata_csv(sys.stdin)
    generate_metric_data_code(metric_metadata)
