# (C) Datadog, Inc. 2026-present
# All rights reserved
# Licensed under a 3-clause BSD style license (see LICENSE)
from __future__ import annotations

from typing import Any, Iterator, Protocol


class HTTPResponseProtocol(Protocol):
    # iter_content and iter_lines return bytes by default, but return str when
    # decode_unicode=True. The precise typing would use @overload with Literal[True]/
    # Literal[False], but that adds significant verbosity to a Protocol stub with no
    # practical benefit at this stage. Iterator[bytes | str] is the honest union: it
    # correctly reflects both runtime cases and avoids false type errors at call sites
    # that pass decode_unicode=True (e.g. the openmetrics mixin). Do not narrow this
    # back to Iterator[bytes] â€” that annotation is wrong for the decode_unicode=True case.
    def iter_content(self, chunk_size: int | None = None, decode_unicode: bool = False) -> Iterator[bytes | str]: ...
    def iter_lines(
        self,
        chunk_size: int | None = None,
        decode_unicode: bool = False,
        delimiter: bytes | str | None = None,
    ) -> Iterator[bytes | str]: ...
    def __enter__(self) -> HTTPResponseProtocol: ...
    def __exit__(self, exc_type: Any, exc_val: Any, exc_tb: Any) -> bool | None: ...


class HTTPClientProtocol(Protocol):
    def get(self, url: str, **options: Any) -> HTTPResponseProtocol: ...
    def post(self, url: str, **options: Any) -> HTTPResponseProtocol: ...
    def head(self, url: str, **options: Any) -> HTTPResponseProtocol: ...
    def put(self, url: str, **options: Any) -> HTTPResponseProtocol: ...
    def patch(self, url: str, **options: Any) -> HTTPResponseProtocol: ...
    def delete(self, url: str, **options: Any) -> HTTPResponseProtocol: ...
    def options_method(self, url: str, **options: Any) -> HTTPResponseProtocol: ...
